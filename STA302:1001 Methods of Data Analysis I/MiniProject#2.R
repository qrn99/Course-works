setwd("~/Desktop/UofT/19_20/STA302")
## ---- setup
library(MASS)
set.seed(1004079631)
nsample <- 10; nsim <- 100 # Set 100 simulations
sig2 <- rchisq(1, df = 1) ## The true error variance
bet <- c(rnorm(3, 0, 1), 0) ## 4 values of beta that is beta0, beta1, beta2, beta3 = 0
beta0 <- bet[1]; beta1 <- bet[2]; beta2 <- bet[3]; beta3 <- bet[4]  ## the population regression parameters

muvec <- rnorm(3, 0, 1)
sigmat <- diag(rchisq(3, df = 4)) # Assume correlation between the three predictors are zero, so off diagonals of sigmat = 0
X <- mvrnorm(nsample, mu = muvec, Sigma = sigmat)
Xmat <- cbind(1, X)
sig2hat <- vector()  # saves the sample estimates of error variance sigma^2s

# To save some time, let's define a function that calculates the true varaiance of estimators: Helper function
var_true <- function(X, sig2, nsample, beta){
  sumx <- sum(X); xbar <- sumx/nsample
  sumx2 <- sum(X^2); SXX <- sumx2 - nsample*(xbar^2)
  var_beta_0 <- sig2*(1/nsample + xbar^2/SXX)
  var_beta_1 <- sig2/SXX
  
  if (beta == 0){
    return(var_beta_0)
  }
  return(var_beta_1)
}

## ---- Q1
## Task1 : Q1 ##
set.seed(1004079631)
b0_1 <- vector(); b0_2 <- vector(); b0_3 <- vector() # saves the sample estimates of beta_0 for SLR of X1-3 predictors
b1 <- vector(); b2 <- vector(); b3 <- vector()  # saves the sample estimates of beta1-3 of SLR with X1-3 predictors
var_b0_1 <- vector(); var_b0_2 <- vector(); var_b0_3 <- vector() # save variance of b0 of SLR with X1-3 predictors
var_b1 <- vector(); var_b2 <- vector(); var_b3 <- vector()   # save variance of b1, b2, b3 of SLR
# saves the sample estimates of error variance sigma^2 with SLR model on X1-3 predictor
sig2hat1 <- vector(); sig2hat2 <- vector(); sig2hat3 <- vector()

bets <- matrix(NA, ncol = length(bet), nrow = nsim)  # MLR: save sample estimators of beta0, beta1, beta2 and beta3
vars <- matrix(NA, ncol = length(bet), nrow = nsim)  # MLR: save sample variance of b0, b1, b2, b3
X1 <- X[,1]; X2 <- X[,2]; X3 <- X[,3]  # save X1, X2, X3 from X, the matrix

## ---- Q1_for_loop
for(i in 1:nsim){
  Y <- Xmat%*%bet + rnorm(nsample, 0, sqrt(sig2))  # Y generated by all 3 predictors
  model1 <- lm(Y ~ X1)  # SLR with X1
  b0_1[i] <- coef(model1)[1]  # store regression parameter estimates of beta_0 of SLR with X1
  b1[i] <- coef(model1)[2]  # store regression parameter estimates of beta_1
  sig2hat1[i] <- summary(model1)$sigma^2  # store error var estimates with X1
  var_b0_1[i] <- summary(model1)$coefficient[1,2]^2  # store variance of b0 of SLR with X1
  var_b1[i] <- summary(model1)$coefficient[2,2]^2  # store variance of b1 of SLR with X1
  
  model2 <- lm(Y ~ X2)  # SLR with X2
  b0_2[i] <- coef(model2)[1]  # store regression parameter estimates of beta_0 of SLR with X2
  b2[i] <- coef(model2)[2]  # store regression parameter estimates of beta_2
  sig2hat2[i] <- summary(model2)$sigma^2  # store error var estimates of SLR with X2
  var_b0_2[i] <- summary(model2)$coefficient[1,2]^2  # store variance of b0 of SLR with X2
  var_b2[i] <- summary(model2)$coefficient[2,2]^2  # store variance of b2 of SLR with X2
  
  model3 <- lm(Y ~ X3)  # SLR with X3
  b0_3[i] <- coef(model3)[1]  # store regression parameter estimates of beta_0 of SLR with X3
  b3[i] <- coef(model3)[2]  # store regression parameter estimates of beta_3
  sig2hat3[i] <- summary(model3)$sigma^2  # store error var estimates of SLR with X3
  var_b0_3[i] <- summary(model3)$coefficient[1,2]^2  # store variance of b0 of SLR with X3
  var_b3[i] <- summary(model3)$coefficient[2,2]^2  # store variance of b2 of SLR with X3
  
  model <- lm(Y ~ X)  # MLR with X1, X2, X3
  bets[i,] <- coef(model)  # assign regression parameter estimates for MLR model with X1-3
  sig2hat[i] <- summary(model)$sigma^2  # store error var estimates under MLR
  vars[i, 1] <- summary(model)$coefficient[1,2]^2  # store variance of b0
  vars[i, 2] <- summary(model)$coefficient[2,2]^2  # store variance of b1
  vars[i, 3] <- summary(model)$coefficient[3,2]^2  # store variance of b2
  vars[i, 4] <- summary(model)$coefficient[4,2]^2  # store variance of b3
}

## ---- SLR_beta1_mean_var
mean(b0_1); mean(b1); mean(sig2hat1)  # The mean of esitmators b0, b1, and error variance s^2 for lm(Y ~ X1)
beta0; beta1; sig2  # The true population parameters beta_0, beta_1, and error variance sigma^2

# Variance of reg parameter estimators for lm(Y ~ X1), SLR of X1 predictor
var_beta_0_1 <- var_true(X1, sig2, nsample, 0); var_beta_1 <- var_true(X1, sig2, nsample, 1)
var_beta_0_1; var_beta_1  # true variance of b0 with X1 as the predictor and b1
mean(var_b0_1); mean(var_b1)  # the mean of the sample variances of b0 and b1

## ---- SLR_beta2_mean_var
mean(b0_2); mean(b2); mean(sig2hat2)  # The mean of esitmators b0, b2, and error variance s^2 for lm(Y ~ X2)
beta0; beta2; sig2  # The true population parameters beta_0, beta_2, and error variance sigma^2

# Variance of reg parameter estimators for lm(Y ~ X2), SLR of X2 predictor
var_beta_0_2 <- var_true(X2, sig2, nsample, 0); var_beta_2 <- var_true(X2, sig2, nsample, 1)
var_beta_0_1; var_beta_2  # true variance of b0 with X2 as the predictor and b2
mean(var_b0_1); mean(var_b2)  # the mean of the sample variances of b0 with X2 as the predictor and b2

## ---- SLR_beta3_mean_var
mean(b0_3); mean(b3); mean(sig2hat3)  # The mean of esitmators b0, b2, and error variance s^2 for lm(Y ~ X3)
beta0; beta3; sig2  # The true population parameters beta_0, beta_3, and error variance sigma^2

# Variance of reg parameter estimators for lm(Y ~ X3), SLR of X3 predictor
var_beta_0_3 <- var_true(X3, sig2, nsample, 0); var_beta_3 <- var_true(X3, sig2, nsample, 1)
var_beta_0_3; var_beta_3  # true variance of b0 with X3 as the predictor and b3
mean(var_b0_3); mean(var_b3)  # the mean of the sample variances of b0 with X3 as the predictor and b3


## ---- MLR_mean
# The mean of esitmators b0, b1, b2, b3, and s^2 for lm(Y ~ X), MLR with 3 predictors
mean(bets[,1]); mean(bets[,2]); mean(bets[,3]); mean(bets[,4]); mean(sig2hat) 
mean(b0_1); mean(b0_2); mean(b0_3)  # The mean of estimators b0 for SLR with each predictor
mean(b1); mean(b2); mean(b3)  # The mean of estimators b1, b2, b3 for SLR with each predictor
beta0; beta1; beta2; beta3; sig2 # The true population paramesters

## ---- MLR_var
# MLR variance of esitmators
XT <- t(Xmat)  # Transpose of Xmat
XTX <- XT%*%Xmat  # X'X
XTX_inverse <- solve(XTX)  #(X'X)^-1 = C
# var(bj) = sig2*C_{jj}
var_beta_0 <- sig2*XTX_inverse[1,1]; var_beta_1 <- sig2*XTX_inverse[2,2]
var_beta_2 <- sig2*XTX_inverse[3,3]; var_beta_3 <- sig2*XTX_inverse[4,4]

var_beta_0; var_beta_1; var_beta_2; var_beta_3  # true variance of b0, b1, b2, b3
mean(vars[,1]); mean(vars[,2]); mean(vars[,3]); mean(vars[,4])  # the mean of the sample variances of b0, b1, b2, b3


## ---- increase sim to see unbiasness
set.seed(1004079631)
sig2hat_sim <- vector()  # MLR: save sample estimators for sig2
bets_sim <- matrix(NA, ncol = length(bet), nrow = 1000)  # MLR: save sample estimators of beta0, beta1, beta2 and beta3
vars_sim <- matrix(NA, ncol = length(bet), nrow = 1000)  # MLR: save sample variance of b0, b1, b2, b3

for(i in 1:1000){
  Y <- Xmat%*%bet + rnorm(nsample, 0, sqrt(sig2))  # Y generated by all 3 predictors

  model_sim <- lm(Y ~ X)  # MLR with X1, X2, X3
  bets_sim[i,] <- coef(model_sim)  # assign regression parameter estimates for MLR model with X1-3
  sig2hat_sim[i] <- summary(model_sim)$sigma^2  # store error var estimates under MLR
  vars_sim[i, 1] <- summary(model_sim)$coefficient[1,2]^2  # store variance of b0
  vars_sim[i, 2] <- summary(model_sim)$coefficient[2,2]^2  # store variance of b1
  vars_sim[i, 3] <- summary(model_sim)$coefficient[3,2]^2  # store variance of b2
  vars_sim[i, 4] <- summary(model_sim)$coefficient[4,2]^2  # store variance of b3
}

## ---- MLR_increase_n.sim_mean
# The mean of esitmators b0, b1, b2, b3, and s^2 for lm(Y ~ X) under 100 n.sim
mean(bets[,1]); mean(bets[,2]); mean(bets[,3]); mean(bets[,4]); mean(sig2hat) 
# The mean of esitmators b0, b1, b2, b3, and s^2 for lm(Y ~ X) under 1000 n.sim
mean(bets_sim[,1]); mean(bets_sim[,2]); mean(bets_sim[,3]); mean(bets_sim[,4]); mean(sig2hat_sim) 
beta0; beta1; beta2; beta3; sig2 # The true population paramesters

## ---- MLR_increase_n.sim_other
# MLR variance of esitmators
XT <- t(Xmat); XTX <- XT%*%Xmat; XTX_inverse <- solve(XTX) 
# var(bj) = sig2*C_{jj}
var_beta_0_sim <- sig2*XTX_inverse[1,1]; var_beta_1_sim <- sig2*XTX_inverse[2,2]
var_beta_2_sim <- sig2*XTX_inverse[3,3]; var_beta_3_sim <- sig2*XTX_inverse[4,4]

## ---- MLR_increase_n.sim_var
# The difference between true vs mean of variance of esitmators b0, b1, b2, b3 under 100 n.sim
var_beta_0-mean(vars[,1]); var_beta_1-mean(vars[,2]); var_beta_2-mean(vars[,3]); var_beta_3-mean(vars[,4])
# The difference between true vs mean of variance of the esitmators b0, b1, b2, b3 under 1000 n.sim
var_beta_0_sim-mean(vars_sim[,1]); var_beta_1_sim-mean(vars_sim[,2]); var_beta_2_sim-mean(vars_sim[,3]); var_beta_3_sim-mean(vars_sim[,4])  # the mean of the sample variances of b0, b1, b2, b3



## ---- correlated_predictors_x1_x2
## Q3 ##
r12 <- 0.2  # Assume X1 and X2 are correlated. Set value for correlation r12 = 0.2, our small r12, also call it r1
sigmat[1,2] <- sigmat[2,1] <- r12*sqrt(sigmat[1,1])*sqrt(sigmat[2,2])
## Simulation for Categorical Variables with Interaction ##
set.seed(1004079631)
X <- mvrnorm(nsample, mu = muvec, Sigma = sigmat); cor(X[,1], X[,2])
Xmat <- cbind(1, X)

# Repeate step 1 & 2, for small correlation, r12=0.2, which is named after _r1
# Not saving what b0, the intercept, is since it is not a focus for interaction among predictors
b1_r1 <- vector(); b2_r1 <- vector(); b3_r1 <- vector()  # saves the sample estimates of beta1-3 of SLR with X1-3 predictors
var_b1_r1 <- vector(); var_b2_r1 <- vector(); var_b3_r1 <- vector()   # save variance of b1, b2, b3 of SLR
# saves the sample estimates of error variance sigma^2 with SLR model on X1-3 predictor
sig2hat1_r1 <- vector(); sig2hat2_r1 <- vector(); sig2hat3_r1 <- vector()

sig2hat_r1 <- vector() # saves the sample estimates of error variance sigma^2 with MLR model on X1-3 predictor
bets_r1 <- matrix(NA, ncol = length(bet), nrow = nsim)  # MLR: save sample estimators of beta0, beta1, beta2 and beta3
vars_r1 <- matrix(NA, ncol = length(bet), nrow = nsim)  # MLR: save sample variance of b0, b1, b2, b3
X1 <- X[,1]; X2 <- X[,2]; X3 <- X[,3]  # save X1, X2, X3 from X, the matrix

for(i in 1:nsim){
  Y <- Xmat%*%bet + rnorm(nsample, 0, sqrt(sig2))  # Y generated by all 3 predictors
  model1_r1 <- lm(Y ~ X1)  # SLR with X1
  b1_r1[i] <- coef(model1_r1)[2]  # store regression parameter estimates of beta_1
  sig2hat1_r1[i] <- summary(model1_r1)$sigma^2  # store error var estimates with X1
  var_b1_r1[i] <- summary(model1_r1)$coefficient[2,2]^2  # store variance of b1 of SLR with X1
  
  model2_r1 <- lm(Y ~ X2)  # SLR with X2
  b2_r1[i] <- coef(model2_r1)[2]  # store regression parameter estimates of beta_2
  sig2hat2_r1[i] <- summary(model2_r1)$sigma^2  # store error var estimates of SLR with X2
  var_b2_r1[i] <- summary(model2_r1)$coefficient[2,2]^2  # store variance of b2 of SLR with X2
  
  model3_r1 <- lm(Y ~ X3)  # SLR with X3
  b3_r1[i] <- coef(model3_r1)[2]  # store regression parameter estimates of beta_3
  sig2hat3_r1[i] <- summary(model3_r1)$sigma^2  # store error var estimates of SLR with X3
  var_b3_r1[i] <- summary(model3_r1)$coefficient[2,2]^2  # store variance of b2 of SLR with X3
  
  model_r1 <- lm(Y ~ X)  # MLR with X1, X2, X3
  bets_r1[i,] <- coef(model_r1)  # assign regression parameter estimates for MLR model with X1-3
  sig2hat_r1[i] <- summary(model_r1)$sigma^2  # store error var estimates under MLR
  vars_r1[i, 1] <- summary(model_r1)$coefficient[1,2]^2  # store variance of b0
  vars_r1[i, 2] <- summary(model_r1)$coefficient[2,2]^2  # store variance of b1
  vars_r1[i, 3] <- summary(model_r1)$coefficient[3,2]^2  # store variance of b2
  vars_r1[i, 4] <- summary(model_r1)$coefficient[4,2]^2  # store variance of b3
}

## ---- SLR_beta1_mean_var_correlated_x1_x2_r1
# For r12 = 0.2
mean(b1_r1); mean(b2_r1); mean(b3_r1)  # The mean of esitmators b1, b2, b3 for each SLR
mean(sig2hat1_r1); mean(sig2hat2_r1); mean(sig2hat3_r1)  # The mean of error variance s^2 for each SLR
mean(var_b1_r1); mean(var_b2_r1); mean(var_b3_r1)  # The mean of the sample variances of b1, b2, b3 for each SLR
beta1; beta2; beta3; sig2 # The true population parameters

## ---- MLR_mean_correlated_x1_x2_r1
mean(bets_r1[,2]); mean(bets_r1[,3]); mean(bets_r1[,4]); mean(sig2hat_r1) # The mean of estimators b1, b2, b3 for MLR
beta1; beta2; beta3; sig2  # The true population paramesters
mean(vars_r1[,2]); mean(vars_r1[,3]); mean(vars_r1[,4])  # the mean of the sample variances of b1, b2, b3


## ---- Increase r12 to 0.5
## The correlation ##
r12 <- 0.5  # Assume X1 and X2 are correlated. Set value for correlation r12 = 0.5, our medium r12, also call it r2
sigmat[1,2] <- sigmat[2,1] <- r12*sqrt(sigmat[1,1])*sqrt(sigmat[2,2])
## Simulation for Categorical Variables with Interaction ##
set.seed(1004079631)
X <- mvrnorm(nsample, mu = muvec, Sigma = sigmat); cor(X[,1], X[,2])
Xmat <- cbind(1, X)

# Repeate step 1 & 2, for medium correlation, r12=0.5, which is named after _r2
# Not saving what b0, the intercept, is since it is not a focus for interaction among predictors
b1_r2 <- vector(); b2_r2 <- vector(); b3_r2 <- vector()  # saves the sample estimates of beta1-3 of SLR with X1-3 predictors
var_b1_r2 <- vector(); var_b2_r2 <- vector(); var_b3_r2 <- vector()   # save variance of b1, b2, b3 of SLR
# saves the sample estimates of error variance sigma^2 with SLR model on X1-3 predictor
sig2hat1_r2 <- vector(); sig2hat2_r2 <- vector(); sig2hat3_r2 <- vector()

sig2hat_r2 <- vector() # saves the sample estimates of error variance sigma^2 with MLR model on X1-3 predictor
bets_r2 <- matrix(NA, ncol = length(bet), nrow = nsim)  # MLR: save sample estimators of beta0, beta1, beta2 and beta3
vars_r2 <- matrix(NA, ncol = length(bet), nrow = nsim)  # MLR: save sample variance of b0, b1, b2, b3
X1 <- X[,1]; X2 <- X[,2]; X3 <- X[,3]  # save X1, X2, X3 from X, the matrix

for(i in 1:nsim){
  Y <- Xmat%*%bet + rnorm(nsample, 0, sqrt(sig2))  # Y generated by all 3 predictors
  model1_r2 <- lm(Y ~ X1)  # SLR with X1
  b1_r2[i] <- coef(model1_r2)[2]  # store regression parameter estimates of beta_1
  sig2hat1_r2[i] <- summary(model1_r2)$sigma^2  # store error var estimates with X1
  var_b1_r2[i] <- summary(model1_r2)$coefficient[2,2]^2  # store variance of b1 of SLR with X1
  
  model2_r2 <- lm(Y ~ X2)  # SLR with X2
  b2_r2[i] <- coef(model2_r2)[2]  # store regression parameter estimates of beta_2
  sig2hat2_r2[i] <- summary(model2_r2)$sigma^2  # store error var estimates of SLR with X2
  var_b2_r2[i] <- summary(model2_r2)$coefficient[2,2]^2  # store variance of b2 of SLR with X2
  
  model3_r2 <- lm(Y ~ X3)  # SLR with X3
  b3_r2[i] <- coef(model3_r2)[2]  # store regression parameter estimates of beta_3
  sig2hat3_r2[i] <- summary(model3_r2)$sigma^2  # store error var estimates of SLR with X3
  var_b3_r2[i] <- summary(model3_r2)$coefficient[2,2]^2  # store variance of b2 of SLR with X3
  
  model_r2 <- lm(Y ~ X)  # MLR with X1, X2, X3
  bets_r2[i,] <- coef(model_r2)  # assign regression parameter estimates for MLR model with X1-3
  sig2hat_r2[i] <- summary(model_r2)$sigma^2  # store error var estimates under MLR
  vars_r2[i, 1] <- summary(model_r2)$coefficient[1,2]^2  # store variance of b0
  vars_r2[i, 2] <- summary(model_r2)$coefficient[2,2]^2  # store variance of b1
  vars_r2[i, 3] <- summary(model_r2)$coefficient[3,2]^2  # store variance of b2
  vars_r2[i, 4] <- summary(model_r2)$coefficient[4,2]^2  # store variance of b3
}

## ---- SLR_beta1_mean_var_correlated_x1_x2_r2
# For r12 = 0.5
mean(b1_r2); mean(b2_r2); mean(b3_r2)  # The mean of esitmators b1, b2, b3 for each SLR
mean(sig2hat1_r2); mean(sig2hat2_r2); mean(sig2hat3_r2)  # The mean of error variance s^2 for each SLR
mean(var_b1_r2); mean(var_b2_r2); mean(var_b3_r2)  # The mean of the sample variances of b1, b2, b3 for each SLR
beta1; beta2; beta3; sig2 # The true population parameters

## ---- MLR_mean_correlated_x1_x2_r2
mean(bets_r2[,2]); mean(bets_r2[,3]); mean(bets_r2[,4]); mean(sig2hat_r2) # The mean of estimators b1, b2, b3 for MLR
beta1; beta2; beta3; sig2  # The true population paramesters
mean(vars_r2[,2]); mean(vars_r2[,3]); mean(vars_r2[,4])  # the mean of the sample variances of b1, b2, b3


## ---- Increase r12 to 0.95
## The correlation ##
r12 <- 0.95  # Assume X1 and X2 are correlated. Set value for correlation r12 = 0.5, our high r12, also call it r3
sigmat[1,2] <- sigmat[2,1] <- r12*sqrt(sigmat[1,1])*sqrt(sigmat[2,2])
## Simulation for Categorical Variables with Interaction ##
set.seed(1004079631)
X <- mvrnorm(nsample, mu = muvec, Sigma = sigmat); cor(X[,1], X[,2])
Xmat <- cbind(1, X)

# Repeate step 1 & 2, for large correlation, r12=0.5, which is named after _r3
# Not saving what b0, the intercept, is since it is not a focus for interaction among predictors
b1_r3 <- vector(); b2_r3 <- vector(); b3_r3 <- vector()  # saves the sample estimates of beta1-3 of SLR with X1-3 predictors
var_b1_r3 <- vector(); var_b2_r3 <- vector(); var_b3_r3 <- vector()   # save variance of b1, b2, b3 of SLR
# saves the sample estimates of error variance sigma^2 with SLR model on X1-3 predictor
sig2hat1_r3 <- vector(); sig2hat2_r3 <- vector(); sig2hat3_r3 <- vector()

sig2hat_r3 <- vector() # saves the sample estimates of error variance sigma^2 with MLR model on X1-3 predictor
bets_r3 <- matrix(NA, ncol = length(bet), nrow = nsim)  # MLR: save sample estimators of beta0, beta1, beta2 and beta3
vars_r3 <- matrix(NA, ncol = length(bet), nrow = nsim)  # MLR: save sample variance of b0, b1, b2, b3
X1 <- X[,1]; X2 <- X[,2]; X3 <- X[,3]  # save X1, X2, X3 from X, the matrix

for(i in 1:nsim){
  Y <- Xmat%*%bet + rnorm(nsample, 0, sqrt(sig2))  # Y generated by all 3 predictors
  model1_r3 <- lm(Y ~ X1)  # SLR with X1
  b1_r3[i] <- coef(model1_r3)[2]  # store regression parameter estimates of beta_1
  sig2hat1_r3[i] <- summary(model1_r3)$sigma^2  # store error var estimates with X1
  var_b1_r3[i] <- summary(model1_r3)$coefficient[2,2]^2  # store variance of b1 of SLR with X1
  
  model2_r3 <- lm(Y ~ X2)  # SLR with X2
  b2_r3[i] <- coef(model2_r3)[2]  # store regression parameter estimates of beta_2
  sig2hat2_r3[i] <- summary(model2_r3)$sigma^2  # store error var estimates of SLR with X2
  var_b2_r3[i] <- summary(model2_r3)$coefficient[2,2]^2  # store variance of b2 of SLR with X2
  
  model3_r3 <- lm(Y ~ X3)  # SLR with X3
  b3_r3[i] <- coef(model3_r3)[2]  # store regression parameter estimates of beta_3
  sig2hat3_r3[i] <- summary(model3_r3)$sigma^2  # store error var estimates of SLR with X3
  var_b3_r3[i] <- summary(model3_r3)$coefficient[2,2]^2  # store variance of b2 of SLR with X3
  
  model_r3 <- lm(Y ~ X)  # MLR with X1, X2, X3
  bets_r3[i,] <- coef(model_r3)  # assign regression parameter estimates for MLR model with X1-3
  sig2hat_r3[i] <- summary(model_r3)$sigma^2  # store error var estimates under MLR
  vars_r3[i, 1] <- summary(model_r3)$coefficient[1,2]^2  # store variance of b0
  vars_r3[i, 2] <- summary(model_r3)$coefficient[2,2]^2  # store variance of b1
  vars_r3[i, 3] <- summary(model_r3)$coefficient[3,2]^2  # store variance of b2
  vars_r3[i, 4] <- summary(model_r3)$coefficient[4,2]^2  # store variance of b3
}

## ---- SLR_beta1_mean_var_correlated_x1_x2_r3
# For r12 = 0.95
mean(b1_r3); mean(b2_r3); mean(b3_r3)  # The mean of esitmators b1, b2, b3 for each SLR
mean(sig2hat1_r3); mean(sig2hat2_r3); mean(sig2hat3_r3)  # The mean of error variance s^2 for each SLR
mean(var_b1_r3); mean(var_b2_r3); mean(var_b3_r3)  # The mean of the sample variances of b1, b2, b3 for each SLR
beta1; beta2; beta3; sig2 # The true population parameters

## ---- MLR_mean_correlated_x1_x2_r3
mean(bets_r3[,2]); mean(bets_r3[,3]); mean(bets_r3[,4]); mean(sig2hat_r3) # The mean of estimators b1, b2, b3 for MLR
beta1; beta2; beta3; sig2  # The true population paramesters
mean(vars_r3[,2]); mean(vars_r3[,3]); mean(vars_r3[,4])  # the mean of the sample variances of b1, b2, b3


## ---- correlated_predictors_x1_x3
## Q4 ##
sigmat[1,2] <- sigmat[2,1] <- 0  # Assume X1, X2 are uncorrelated, set to 0
r13 <- 0.2  # Assume X1 and X3 are correlated. Set value for correlation r13 = 0.2, our small r13, also call it r4
sigmat[1,3] <- sigmat[3,1] <- r13*sqrt(sigmat[1,1])*sqrt(sigmat[3,3])
## Simulation for Categorical Variables with Interaction ##
set.seed(1004079631)
X <- mvrnorm(nsample, mu = muvec, Sigma = sigmat); cor(X[,1], X[,3])
Xmat <- cbind(1, X)

# Repeate step 1 & 2, for small correlation, r13=0.2, which is named after _r4
# Not saving what b0, the intercept, is since it is not a focus for interaction among predictors
b1_r4 <- vector(); b2_r4 <- vector(); b3_r4 <- vector()  # saves the sample estimates of beta1-3 of SLR with X1-3 predictors
var_b1_r4 <- vector(); var_b2_r4 <- vector(); var_b3_r4 <- vector()   # save variance of b1, b2, b3 of SLR
# saves the sample estimates of error variance sigma^2 with SLR model on X1-3 predictor
sig2hat1_r4 <- vector(); sig2hat2_r4 <- vector(); sig2hat3_r4 <- vector()

sig2hat_r4 <- vector() # saves the sample estimates of error variance sigma^2 with MLR model on X1-3 predictor
bets_r4 <- matrix(NA, ncol = length(bet), nrow = nsim)  # MLR: save sample estimators of beta0, beta1, beta2 and beta3
vars_r4 <- matrix(NA, ncol = length(bet), nrow = nsim)  # MLR: save sample variance of b0, b1, b2, b3
X1 <- X[,1]; X2 <- X[,2]; X3 <- X[,3]  # save X1, X2, X3 from X, the matrix

for(i in 1:nsim){
  Y <- Xmat%*%bet + rnorm(nsample, 0, sqrt(sig2))  # Y generated by all 3 predictors
  model1_r4 <- lm(Y ~ X1)  # SLR with X1
  b1_r4[i] <- coef(model1_r4)[2]  # store regression parameter estimates of beta_1
  sig2hat1_r4[i] <- summary(model1_r4)$sigma^2  # store error var estimates with X1
  var_b1_r4[i] <- summary(model1_r4)$coefficient[2,2]^2  # store variance of b1 of SLR with X1
  
  model2_r4 <- lm(Y ~ X2)  # SLR with X2
  b2_r4[i] <- coef(model2_r4)[2]  # store regression parameter estimates of beta_2
  sig2hat2_r4[i] <- summary(model2_r4)$sigma^2  # store error var estimates of SLR with X2
  var_b2_r4[i] <- summary(model2_r4)$coefficient[2,2]^2  # store variance of b2 of SLR with X2
  
  model3_r4 <- lm(Y ~ X3)  # SLR with X3
  b3_r4[i] <- coef(model3_r4)[2]  # store regression parameter estimates of beta_3
  sig2hat3_r4[i] <- summary(model3_r4)$sigma^2  # store error var estimates of SLR with X3
  var_b3_r4[i] <- summary(model3_r4)$coefficient[2,2]^2  # store variance of b2 of SLR with X3
  
  model_r4 <- lm(Y ~ X)  # MLR with X1, X2, X3
  bets_r4[i,] <- coef(model_r4)  # assign regression parameter estimates for MLR model with X1-3
  sig2hat_r4[i] <- summary(model_r4)$sigma^2  # store error var estimates under MLR
  vars_r4[i, 1] <- summary(model_r4)$coefficient[1,2]^2  # store variance of b0
  vars_r4[i, 2] <- summary(model_r4)$coefficient[2,2]^2  # store variance of b1
  vars_r4[i, 3] <- summary(model_r4)$coefficient[3,2]^2  # store variance of b2
  vars_r4[i, 4] <- summary(model_r4)$coefficient[4,2]^2  # store variance of b3
}

## ---- SLR_beta1_mean_var_correlated_x1_x3_r4
# For r13 = 0.2
mean(b1_r4); mean(b2_r4); mean(b3_r4)  # The mean of esitmators b1, b2, b3 for each SLR
mean(sig2hat1_r4); mean(sig2hat2_r4); mean(sig2hat3_r4)  # The mean of error variance s^2 for each SLR
mean(var_b1_r4); mean(var_b2_r4); mean(var_b3_r4)  # The mean of the sample variances of b1, b2, b3 for each SLR
beta1; beta2; beta3; sig2 # The true population parameters

## ---- MLR_mean_correlated_x1_x3_r4
mean(bets_r4[,2]); mean(bets_r4[,3]); mean(bets_r4[,4]); mean(sig2hat_r4) # The mean of estimators b1, b2, b3 for MLR
beta1; beta2; beta3; sig2  # The true population paramesters
mean(vars_r4[,2]); mean(vars_r4[,3]); mean(vars_r4[,4])  # the mean of the sample variances of b1, b2, b3


## ---- Increase r13 to 0.5
## The correlation ##
sigmat[1,2] <- sigmat[2,1] <- 0  # Assume X1, X2 are uncorrelated, set to 0
r13 <- 0.5  # Assume X1 and X3 are correlated. Set value for correlation r13 = 0.5, our medium r13, also call it r4
sigmat[1,3] <- sigmat[3,1] <- r13*sqrt(sigmat[1,1])*sqrt(sigmat[3,3])
## Simulation for Categorical Variables with Interaction ##
set.seed(1004079631)
X <- mvrnorm(nsample, mu = muvec, Sigma = sigmat); cor(X[,1], X[,3])
Xmat <- cbind(1, X)

# Repeate step 1 & 2, for medium correlation, r13=0.5, which is named after _r5
# Not saving what b0, the intercept, is since it is not a focus for interaction among predictors
b1_r5 <- vector(); b2_r5 <- vector(); b3_r5 <- vector()  # saves the sample estimates of beta1-3 of SLR with X1-3 predictors
var_b1_r5 <- vector(); var_b2_r5 <- vector(); var_b3_r5 <- vector()   # save variance of b1, b2, b3 of SLR
# saves the sample estimates of error variance sigma^2 with SLR model on X1-3 predictor
sig2hat1_r5 <- vector(); sig2hat2_r5 <- vector(); sig2hat3_r5 <- vector()

sig2hat_r5 <- vector() # saves the sample estimates of error variance sigma^2 with MLR model on X1-3 predictor
bets_r5 <- matrix(NA, ncol = length(bet), nrow = nsim)  # MLR: save sample estimators of beta0, beta1, beta2 and beta3
vars_r5 <- matrix(NA, ncol = length(bet), nrow = nsim)  # MLR: save sample variance of b0, b1, b2, b3
X1 <- X[,1]; X2 <- X[,2]; X3 <- X[,3]  # save X1, X2, X3 from X, the matrix

for(i in 1:nsim){
  Y <- Xmat%*%bet + rnorm(nsample, 0, sqrt(sig2))  # Y generated by all 3 predictors
  model1_r5 <- lm(Y ~ X1)  # SLR with X1
  b1_r5[i] <- coef(model1_r5)[2]  # store regression parameter estimates of beta_1
  sig2hat1_r5[i] <- summary(model1_r5)$sigma^2  # store error var estimates with X1
  var_b1_r5[i] <- summary(model1_r5)$coefficient[2,2]^2  # store variance of b1 of SLR with X1
  
  model2_r5 <- lm(Y ~ X2)  # SLR with X2
  b2_r5[i] <- coef(model2_r5)[2]  # store regression parameter estimates of beta_2
  sig2hat2_r5[i] <- summary(model2_r5)$sigma^2  # store error var estimates of SLR with X2
  var_b2_r5[i] <- summary(model2_r5)$coefficient[2,2]^2  # store variance of b2 of SLR with X2
  
  model3_r5 <- lm(Y ~ X3)  # SLR with X3
  b3_r5[i] <- coef(model3_r5)[2]  # store regression parameter estimates of beta_3
  sig2hat3_r5[i] <- summary(model3_r5)$sigma^2  # store error var estimates of SLR with X3
  var_b3_r5[i] <- summary(model3_r5)$coefficient[2,2]^2  # store variance of b2 of SLR with X3
  
  model_r5 <- lm(Y ~ X)  # MLR with X1, X2, X3
  bets_r5[i,] <- coef(model_r5)  # assign regression parameter estimates for MLR model with X1-3
  sig2hat_r5[i] <- summary(model_r5)$sigma^2  # store error var estimates under MLR
  vars_r5[i, 1] <- summary(model_r5)$coefficient[1,2]^2  # store variance of b0
  vars_r5[i, 2] <- summary(model_r5)$coefficient[2,2]^2  # store variance of b1
  vars_r5[i, 3] <- summary(model_r5)$coefficient[3,2]^2  # store variance of b2
  vars_r5[i, 4] <- summary(model_r5)$coefficient[4,2]^2  # store variance of b3
}

## ---- SLR_beta1_mean_var_correlated_x1_x3_r5
# For r13 = 0.5
mean(b1_r5); mean(b2_r5); mean(b3_r5)  # The mean of esitmators b1, b2, b3 for each SLR
mean(sig2hat1_r5); mean(sig2hat2_r5); mean(sig2hat3_r5)  # The mean of error variance s^2 for each SLR
mean(var_b1_r5); mean(var_b2_r5); mean(var_b3_r5)  # The mean of the sample variances of b1, b2, b3 for each SLR
beta1; beta2; beta3; sig2 # The true population parameters

## ---- MLR_mean_correlated_x1_x3_r5
mean(bets_r5[,2]); mean(bets_r5[,3]); mean(bets_r5[,4]); mean(sig2hat_r5) # The mean of estimators b1, b2, b3 for MLR
beta1; beta2; beta3; sig2  # The true population paramesters
mean(vars_r5[,2]); mean(vars_r5[,3]); mean(vars_r5[,4])  # the mean of the sample variances of b1, b2, b3


## ---- Increase r13 to 0.95
## The correlation ##
sigmat[1,2] <- sigmat[2,1] <- 0  # Assume X1, X2 are uncorrelated, set to 0
r13 <- 0.95  # Assume X1 and X3 are correlated. Set value for correlation r13 = 0.95, our large r13, also call it r6
sigmat[1,3] <- sigmat[3,1] <- r13*sqrt(sigmat[1,1])*sqrt(sigmat[3,3])
## Simulation for Categorical Variables with Interaction ##
set.seed(1004079631)
X <- mvrnorm(nsample, mu = muvec, Sigma = sigmat); cor(X[,1], X[,3])
Xmat <- cbind(1, X)

# Repeate step 1 & 2, for large correlation, r13=0.95, which is named after _r6
# Not saving what b0, the intercept, is since it is not a focus for interaction among predictors
b1_r6 <- vector(); b2_r6 <- vector(); b3_r6 <- vector()  # saves the sample estimates of beta1-3 of SLR with X1-3 predictors
var_b1_r6 <- vector(); var_b2_r6 <- vector(); var_b3_r6 <- vector()   # save variance of b1, b2, b3 of SLR
# saves the sample estimates of error variance sigma^2 with SLR model on X1-3 predictor
sig2hat1_r6 <- vector(); sig2hat2_r6 <- vector(); sig2hat3_r6 <- vector()

sig2hat_r6 <- vector() # saves the sample estimates of error variance sigma^2 with MLR model on X1-3 predictor
bets_r6 <- matrix(NA, ncol = length(bet), nrow = nsim)  # MLR: save sample estimators of beta0, beta1, beta2 and beta3
vars_r6 <- matrix(NA, ncol = length(bet), nrow = nsim)  # MLR: save sample variance of b0, b1, b2, b3
X1 <- X[,1]; X2 <- X[,2]; X3 <- X[,3]  # save X1, X2, X3 from X, the matrix

for(i in 1:nsim){
  Y <- Xmat%*%bet + rnorm(nsample, 0, sqrt(sig2))  # Y generated by all 3 predictors
  model1_r6 <- lm(Y ~ X1)  # SLR with X1
  b1_r6[i] <- coef(model1_r6)[2]  # store regression parameter estimates of beta_1
  sig2hat1_r6[i] <- summary(model1_r6)$sigma^2  # store error var estimates with X1
  var_b1_r6[i] <- summary(model1_r6)$coefficient[2,2]^2  # store variance of b1 of SLR with X1
  
  model2_r6 <- lm(Y ~ X2)  # SLR with X2
  b2_r6[i] <- coef(model2_r6)[2]  # store regression parameter estimates of beta_2
  sig2hat2_r6[i] <- summary(model2_r6)$sigma^2  # store error var estimates of SLR with X2
  var_b2_r6[i] <- summary(model2_r6)$coefficient[2,2]^2  # store variance of b2 of SLR with X2
  
  model3_r6 <- lm(Y ~ X3)  # SLR with X3
  b3_r6[i] <- coef(model3_r6)[2]  # store regression parameter estimates of beta_3
  sig2hat3_r6[i] <- summary(model3_r6)$sigma^2  # store error var estimates of SLR with X3
  var_b3_r6[i] <- summary(model3_r6)$coefficient[2,2]^2  # store variance of b2 of SLR with X3
  
  model_r6 <- lm(Y ~ X)  # MLR with X1, X2, X3
  bets_r6[i,] <- coef(model_r6)  # assign regression parameter estimates for MLR model with X1-3
  sig2hat_r6[i] <- summary(model_r6)$sigma^2  # store error var estimates under MLR
  vars_r6[i, 1] <- summary(model_r6)$coefficient[1,2]^2  # store variance of b0
  vars_r6[i, 2] <- summary(model_r6)$coefficient[2,2]^2  # store variance of b1
  vars_r6[i, 3] <- summary(model_r6)$coefficient[3,2]^2  # store variance of b2
  vars_r6[i, 4] <- summary(model_r6)$coefficient[4,2]^2  # store variance of b3
}

## ---- SLR_beta1_mean_var_correlated_x1_x3_r6
# For r13 = 0.95
mean(b1_r6); mean(b2_r6); mean(b3_r6)  # The mean of esitmators b1, b2, b3 for each SLR
mean(sig2hat1_r6); mean(sig2hat2_r6); mean(sig2hat3_r6)  # The mean of error variance s^2 for each SLR
mean(var_b1_r6); mean(var_b2_r6); mean(var_b3_r6)  # The mean of the sample variances of b1, b2, b3 for each SLR
beta1; beta2; beta3; sig2 # The true population parameters

## ---- MLR_mean_correlated_x1_x3_r6
mean(bets_r6[,2]); mean(bets_r6[,3]); mean(bets_r6[,4]); mean(sig2hat_r6) # The mean of estimators b1, b2, b3 for MLR
beta1; beta2; beta3; sig2  # The true population paramesters
mean(vars_r6[,2]); mean(vars_r6[,3]); mean(vars_r6[,4])  # the mean of the sample variances of b1, b2, b3



## ---- setup_task2
## Task2 ##
# This following function provides a data set with p+1 columns #
gendata <- function(n, p){
  Xmat <- matrix(runif(n*p, 0, 1), nrow = n, ncol = p)
  Y <- 4*( (sin(pi*Xmat[,1]*Xmat[,2])) + 8*(Xmat[,3] - 0.5)^3 +
             1.5*Xmat[,4] - Xmat[,5] - 0.77 ) + rnorm(n, 0, 1)
  dat <- cbind(Xmat, Y)
  return(dat)
}

set.seed(1004079631)
dat <- as.data.frame(gendata(500, 5))
colnames(dat) <- c(paste0("X", 1:5), "Y")

## Q1 ##
# MLR model
model <- lm(dat$Y ~ ., data = dat)  # p=5, n=500
Y_hat <- predict(model)  # the fitted values by the MLR model, Y_hat

## ---- summary_model
summary(model)  # Check p-value, R^2 adjusted

## ---- normal_qq
# Normal Q-Q plot
r <- rstudent(model)  # standardized residual for the model
qqnorm(r); qqline(r)

## ---- residual_plots
pdf("residual_plots", height = 7, width = 14)
par(mar=c(1,1,1,1)); par(mfrow = c(3,2), mai = c(0.3, 0.3, 0.3, 0.3))  # set up the margin for the residual plots
# Standardized Residual plot for X1
plot(dat$X1, r, type = "p", xlab = "X1", ylab = "Standardized Residuals", main = "Standardized Residual plot with X1", col = "blue")
abline(h = 2, lty = 2); abline(h = -2, lty = 2); abline(h = 0, lwd = 0.8)

# Standardized Residual plot for X2
plot(dat$X2, r, type = "p", xlab = "X2", ylab = "Standardized Residuals", main = "Standardized Residual plot with X2", col = "blue")
abline(h = 2, lty = 2); abline(h = -2, lty = 2); abline(h = 0, lwd = 0.8)

# Standardized Residual plot for X3
plot(dat$X3, r, type = "p", xlab = "X3", ylab = "Standardized Residuals", main = "Standardized Residual plot with X3", col = "blue")
abline(h = 2, lty = 2); abline(h = -2, lty = 2); abline(h = 0, lwd = 0.8)

# Standardized Residual plot for X4
plot(dat$X4, r, type = "p", xlab = "X4", ylab = "Standardized Residuals", main = "Standardized Residual plot with X4", col = "blue")
abline(h = 2, lty = 2); abline(h = -2, lty = 2); abline(h = 0, lwd = 0.8)

# Standardized Residual plot for X5
plot(dat$X5, r, type = "p", xlab = "X5", ylab = "Standardized Residuals", main = "Standardized Residual plot with X5", col = "blue")
abline(h = 2, lty = 2); abline(h = -2, lty = 2); abline(h = 0, lwd = 0.8)
dev.off()

## ---- residual_plots_important
par(mfrow = c(1,1), mai = c(1, 1, 0.5, 0.5))  # set up margin for important plots
# Standardized Residual plot for fitted y-values, Y_hat
plot(Y_hat, r, type = "p", xlab = "Fitted Values Y_hat", ylab = "Standardized Residuals", main = "Standardized Residuals Plot with Fitted Values Y_hat", col = "blue")
abline(h = 2, lty = 2); abline(h = -2, lty = 2); abline(h = 0, lwd = 0.8); lines(lowess(Y_hat, r), col="red")

## ---- scatter_plot_important
# response vs fitted values Y_hat
plot(dat$Y ~ Y_hat, type="p", xlab="Fitted Values Y_hat", ylab="Y", main = "Scatter Plot with Y vs Fitted Values Y_hat", cex.lab=1.2, col='red')
abline(lm(dat$Y ~ Y_hat), lwd=2, col="blue"); lines(lowess(Y_hat, dat$Y), col="green")

## ---- inf_obs
# Cook's distance
D <- cooks.distance(model); which(D > qf(0.5, 6, 500-5-1))  # 50th percentile of F with p+1 and n-p-1 df

# DFFITS
dfits <- dffits(model); which(abs(dfits) > 2*sqrt(6/500))  # 2*sqrt((p+1)/n)

# DFBETAS
dfb <- dfbetas(model); which(abs(dfb[,1]) > 2/sqrt(500))  # 2*sqrt(1/n)


## ---- T2Q2_setup_and_PE
## Q2 ##
dat.new <- as.data.frame(gendata(200, 5)); colnames(dat.new) <- c(paste0("X", 1:5), "Y")
pred.y <- predict(model, newdata = dat.new, type = "response", interval = "none")

PE <- mean((dat.new$Y - pred.y)^2); PE  # Prediction error


## ---- transf
## Q3 ##
library(car) # Box_Cov
mult <- lm(cbind(dat$Y, dat$X1, dat$X2, dat$X3, dat$X4, dat$X5) ~ 1); bc <- powerTransform(mult)
summary(bc)

## ---- true_transf
# True Transformation: Know Y = 4sin(pi*x1*x2) + 32(x3-0.5)^3 + 6*x4 - 4*x5 - 0.77*4 + epsilon
Z1 <- sin(pi*dat$X1*dat$X2); Z2 <- (dat$X3-0.5)**3; Z3 <- dat$X4; Z4 <- dat$X5   # X4, X5 no change
# Then Y = 4*Z1 + 32*Z2 + 6*Z3 - 4*Z4 - 0.77*4 + epsilon, a linear relation with predictor variables Z1-4
model_new <- lm(dat$Y ~ Z1 + Z2 + Z3 + Z4)  # p=4, n=500
Y_hat_new <- predict(model_new)  # the fitted values by the MLR model, Y_hat

## ---- summary_model_new
summary(model_new); # Check p-value, R^2 adjusted

## ---- normal_qq_new
# Normal Q-Q plot
r_new <- rstudent(model_new)  # standardized residual for the model
qqnorm(r_new); qqline(r_new)

## ---- residual_plots_new
pdf("residual_plots_new", height = 7, width = 14)
par(mar=c(1,1,1,1)); par(mfrow = c(2,2), mai = c(0.3, 0.3, 0.3, 0.3))  # set up the margin for the residual plots
# Standardized Residual plot for Z1
plot(Z1, r_new, type = "p", xlab = "Z1", ylab = "Standardized Residuals", main = "Standardized Residual plot with Z1", col = "blue")
abline(h = 2, lty = 2); abline(h = -2, lty = 2); abline(h = 0, lwd = 0.8)

# Standardized Residual plot for Z2
plot(Z2, r_new, type = "p", xlab = "Z2", ylab = "Standardized Residuals", main = "Standardized Residual plot with Z2", col = "blue")
abline(h = 2, lty = 2); abline(h = -2, lty = 2); abline(h = 0, lwd = 0.8)

# Standardized Residual plot for Z3
plot(Z3, r_new, type = "p", xlab = "Z3", ylab = "Standardized Residuals", main = "Standardized Residual plot with Z3", col = "blue")
abline(h = 2, lty = 2); abline(h = -2, lty = 2); abline(h = 0, lwd = 0.8)

# Standardized Residual plot for Z4
plot(Z4, r_new, type = "p", xlab = "Z4", ylab = "Standardized Residuals", main = "Standardized Residual plot with Z4", col = "blue")
abline(h = 2, lty = 2); abline(h = -2, lty = 2); abline(h = 0, lwd = 0.8)
dev.off()

## ---- residual_plots_important_new
par(mfrow = c(1,1), mai = c(1, 1, 0.5, 0.5))  # set up margin for important plots
# Standardized Residual plot for fitted y-values, Y_hat_new
plot(Y_hat_new, r_new, type = "p", xlab = "Fitted Values Y_hat_new", ylab = "Standardized Residuals", main = "Standardized Residuals Plot with Fitted Values Y_hat_new", col = "blue")
abline(h = 2, lty = 2); abline(h = -2, lty = 2); abline(h = 0, lwd = 0.8); lines(lowess(Y_hat, r), col="red")

## ---- scatter_plot_important_new
# response vs fitted values Y_hat
plot(dat$Y ~ Y_hat_new, type="p", xlab="Fitted Values Y_hat_new", ylab="Y", main = "Scatter Plot with Y vs Fitted Values Y_hat_new", cex.lab=1.2, col='red')
abline(lm(dat$Y ~ Y_hat), lwd=2, col="blue"); lines(lowess(Y_hat, dat$Y), col="green")

## ---- inf_obs_new
# Cook's distance
D <- cooks.distance(model_new); which(D > qf(0.5, 5, 500-4-1))  # 50th percentile of F with p+1 and n-p-1 df

# DFFITS
dfits <- dffits(model_new); which(abs(dfits) > 2*sqrt(5/500))  # 2*sqrt((p+1)/n)

# DFBETAS
dfb <- dfbetas(model_new); which(abs(dfb[,1]) > 2/sqrt(500))  # 2*sqrt(1/n)

## ---- T2Q3_PE
dat.new_bf_transf <- as.data.frame(gendata(200, 5)); colnames(dat.new_bf_transf) <- c(paste0("X", 1:5), "Y")
dat.new_af_transf <- as.data.frame(cbind(sin(pi*dat.new_bf_transf$X1*dat.new_bf_transf$X2), (dat.new_bf_transf$X3-0.5)**3, dat.new_bf_transf$X4, dat.new_bf_transf$X5, dat.new_bf_transf$Y))
colnames(dat.new_af_transf) <- c(paste0("Z", 1:4), "Y")
pred.y_new <- predict(model_new, newdata = dat.new_af_transf, type = "response", interval = "none")

PE_new <- mean((dat.new_af_transf$Y - pred.y_new)^2); PE_new  # New Prediction error after transformation
PE # Prediction error before transformation
